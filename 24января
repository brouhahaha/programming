import re    
regbook=r"\bкниг(а(х|м?и?)?|и|е|у|о)?\b"
def clovo():
    word=input('введи слово')
    if re.search(regbook,word)!=None:
        print('Это форма слова книга')
    else:
        print('Это не форма слова книга')
def tekst():
    with open ('new.txt', 'r', encoding='utf-8') as f:
        text=f.readlines()
        for line in text:
            words=line.split()
        for word in words:
            if re.search (regbook, text)!=None:
                return print('есть')
            else:
                return print ('нет')

tekst() 
        
# str.endswith()
# модули в питоне : math, random, os/shutil файловая сисетмв, re регулярные выражения

# \ - экранирующий символ : \n новая строка \t табуляция \' кавычки

#r\ r=rawstring питон воспринимает бэкслэш не как специальный символ, а как просто бэкслеш (применимо ко всем символам)
# регулярные выражения позволяю т искать нужные фрагменты текста
# | "или"  ? "предыдущего символа можем не быть" () группировка

# import re - импортируем функции
#match - часть чтроки, которая попадает под совпадение
# часть ограниченная () - группа group
#* предыдущий имвол или группа повторённфе о любое клово раз 
#+ символы повторенные полож колво раз   берет максимальное колво элементов
#* любое колво любых символов, включая ноль            юерет максимальное волко элтов        

# [...] [abc] один из перечисленных
# [a-z] символ из диапазона
# [A-Za-zё] комбинировать ОК
# экранирование метсимволов
# r'[А-Яа-яЁё]+\?'
# регулярное выражение - это строка

#import re
#regex=r'\[?кот\]?'
##s=какая-то строка
#m=re.search(regex, s)
#if m!=None:
#    print ('я нашел')
#    print(m.group) - отрезочек в котором нашел
#re.search перестает работать при первом нахождении

#regCat=r"\bкот(ы|e|у|о[мв]э|а(х|ми?)?)?\b"

